webpackJsonp([309],{1226:function(e,_){e.exports={render:function(){var e=this,_=e.$createElement;e._self._c;return e._m(0)},staticRenderFns:[function(){var e=this,_=e.$createElement,l=e._self._c||_;return l("section",[l("p",[l("strong",[e._v("ldd命令")]),e._v("用于打印程序或者库文件所依赖的共享库列表。")]),e._v(" "),l("h3",[e._v("语法")]),e._v(" "),l("pre",{pre:!0},[l("code",{attrs:{"v-pre":""}},[e._v("ldd(选项)(参数)\n")])]),e._v(" "),l("h3",[e._v("选项")]),e._v(" "),l("pre",{pre:!0},[l("code",{attrs:{"v-pre":""}},[e._v('--version：打印指令版本号；\n-v：详细信息模式，打印所有相关信息；\n-u：打印未使用的直接依赖；\n-d：执行重定位和报告任何丢失的对象；\n-r：执行数据对象和函数的重定位，并且报告任何丢失的对象和函数；\n--[help](#/help "help命令")：显示帮助信息。\n')])]),e._v(" "),l("h3",[e._v("参数")]),e._v(" "),l("p",[e._v("文件：指定可执行程序或者文库。")]),e._v(" "),l("h3",[e._v("其他介绍")]),e._v(" "),l("p",[e._v("首先ldd不是一个可执行程序，而只是一个shell脚本")]),e._v(" "),l("p",[e._v("ldd能够显示可执行模块的dependency，其原理是通过设置一系列的环境变量，如下："),l("code",{pre:!0},[e._v("LD_TRACE_LOADED_OBJECTS、LD_WARN、LD_BIND_NOW、LD_LIBRARY_VERSION、LD_VERBOSE")]),e._v("等。当"),l("code",{pre:!0},[e._v("LD_TRACE_LOADED_OBJECTS")]),e._v("环境变量不为空时，任何可执行程序在运行时，它都会只显示模块的dependency，而程序并不真正执行。要不你可以在shell终端测试一下，如下：")]),e._v(" "),l("pre",{pre:!0},[l("code",{attrs:{"v-pre":""}},[e._v('[export](#/export "export命令") LD_TRACE_LOADED_OBJECTS=1\n')])]),e._v(" "),l("p",[e._v("再执行任何的程序，如"),l("a",{attrs:{href:"#/ls",title:"ls命令"}},[e._v("ls")]),e._v("等，看看程序的运行结果。")]),e._v(" "),l("p",[e._v("ldd显示可执行模块的dependency的工作原理，其实质是通过"),l("a",{attrs:{href:"#/ld",title:"ld命令"}},[e._v("ld")]),e._v("-linux.so（elf动态库的装载器）来实现的。我们知道，ld-linux.so模块会先于executable模块程序工作，并获得控制权，因此当上述的那些环境变量被设置时，ld-linux.so选择了显示可执行模块的dependency。")]),e._v(" "),l("p",[e._v("实际上可以直接执行ld-linux.so模块，如："),l("code",{pre:!0},[e._v("/lib/ld-linux.so.2 --list program")]),e._v("（这相当于ldd program）")])])}]}},242:function(e,_,l){e.exports=l(831)},831:function(e,_,l){var n=l(5)(null,l(1226),null,null,null);e.exports=n.exports}});
//# sourceMappingURL=309.15f2f8365225377a802f.js.map