webpackJsonp([265],{1353:function(e,n){e.exports={render:function(){var e=this,n=e.$createElement;e._self._c;return e._m(0)},staticRenderFns:[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("section",[t("p",[t("strong",[e._v("make命令")]),e._v("是GNU的工程化编译工具，用于编译众多相互关联的源代码问价，以实现工程化的管理，提高开发效率。")]),e._v(" "),t("h3",[e._v("语法")]),e._v(" "),t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[e._v("make(选项)(参数)\n")])]),e._v(" "),t("h3",[e._v("选项")]),e._v(" "),t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[e._v('-f：指定“makefile”文件；\n-i：忽略命令执行返回的出错信息；\n-s：沉默模式，在执行之前不输出相应的命令行信息；\n-r：禁止使用build-in规则；\n-n：非执行模式，输出所有执行命令，但并不执行；\n-t：更新目标文件；\n-q：make操作将根据目标文件是否已经更新返回"0"或非"0"的状态信息；\n-p：输出所有宏定义和目标文件描述；\n-d：Debug模式，输出有关文件和检测时间的详细信息。\n')])]),e._v(" "),t("p",[e._v("Linux下常用选项与Unix系统中稍有不同，下面是不同的部分：")]),e._v(" "),t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[e._v('-c dir：在读取 makefile 之前改变到指定的目录dir；\n-I dir：当包含其他 makefile文件时，利用该选项指定搜索目录；\n-h：[help](#/help "help命令")文挡，显示所有的make选项；\n-[w](#/w "w命令")：在处理 makefile 之前和之后，都显示工作目录。\n')])]),e._v(" "),t("h3",[e._v("参数")]),e._v(" "),t("p",[e._v("目标：指定编译目标。")]),e._v(" "),t("h3",[e._v("知识扩展")]),e._v(" "),t("p",[e._v("无论是在linux 还是在Unix环境 中，make都是一个非常重要的编译命令。不管是自己进行项目开发还是安装应用软件，我们都经常要用到make或make "),t("a",{attrs:{href:"#/install",title:"install命令"}},[e._v("install")]),e._v("。利用make工具，我们可以将大型的开发项目分解成为多个更易于管理的模块，对于一个包括几百个源文件的应用程序，使用make和 makefile工具就可以简洁明快地理顺各个源文件之间纷繁复杂的相互关系。")]),e._v(" "),t("p",[e._v("而且如此多的源文件，如果每次都要键入"),t("a",{attrs:{href:"#/gcc",title:"gcc命令"}},[e._v("gcc")]),e._v("命令进行编译的话，那对程序员 来说简直就是一场灾难。而make工具则可自动完成编译工作，并且可以只对程序员在上次编译后修改过的部分进行编译。")]),e._v(" "),t("p",[e._v("因此，有效的利用make和 makefile工具可以大大提高项目开发的效率。同时掌握make和makefile之后，您也不会再面对着Linux下的应用软件手足无措了。")])])}]}},287:function(e,n,t){e.exports=t(876)},876:function(e,n,t){var r=t(5)(null,t(1353),null,null,null);e.exports=r.exports}});
//# sourceMappingURL=265.da6ceb50631d99c16a32.js.map