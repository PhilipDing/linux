webpackJsonp([382],{1213:function(n,e){n.exports={render:function(){var n=this,e=n.$createElement;n._self._c;return n._m(0)},staticRenderFns:[function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("section",[t("p",[t("strong",[n._v("gdb命令")]),n._v("包含在GNU的"),t("a",{attrs:{href:"#/gcc",title:"gcc命令"}},[n._v("gcc")]),n._v("开发套件中，是功能强大的程序调试器。GDB中的命令固然很多，但我们只需掌握其中十个左右的命令，就大致可以完成日常的基本的程序调试工作。")]),n._v(" "),t("table",{attrs:{border:"0",cellpadding:"0",cellspacing:"0"}},[t("tbody",[t("tr",[t("th",[n._v("命令")]),n._v(" "),t("th",[n._v("解释")]),n._v(" "),t("th",[n._v("示例")])]),n._v(" "),t("tr",[t("td",[n._v('[file](#/file "file命令") <文件名></文件名>')]),n._v(" "),t("td",[n._v("加载被调试的可执行程序文件。  \n因为一般都在被调试程序所在目录下执行GDB，因而文本名不需要带路径。")]),n._v(" "),t("td",[n._v("(gdb) file gdb-sample")])]),n._v(" "),t("tr",[t("td",[n._v("r")]),n._v(" "),t("td",[n._v("Run的简写，运行被调试的程序。  \n如果此前没有下过断点，则执行完整个程序；如果有断点，则程序暂停在第一个可用断点处。")]),n._v(" "),t("td",[n._v("(gdb) r")])]),n._v(" "),t("tr",[t("td",[n._v("c")]),n._v(" "),t("td",[n._v("Continue的简写，继续执行被调试程序，直至下一个断点或程序结束。")]),n._v(" "),t("td",[n._v("(gdb) c")])]),n._v(" "),t("tr",[t("td",[n._v("b <行号>  \nb <函数名称>  \nb *<函数名称>  \nb *<代码地址> d [编号]</代码地址></函数名称></函数名称></行号>")]),n._v(" "),t("td",[n._v("b: Breakpoint的简写，设置断点。两可以使用“行号”“函数名称”“执行地址”等方式指定断点位置。  \n其中在函数名称前面加“*”符号表示将断点设置在“由编译器生成的prolog代码处”。如果不了解汇编，可以不予理会此用法。 d: Delete breakpoint的简写，删除指定编号的某个断点，或删除所有断点。断点编号从1开始递增。")]),n._v(" "),t("td",[n._v("(gdb) b 8  \n(gdb) b main  \n(gdb) b *main  \n(gdb) b *0x804835c (gdb) d")])]),n._v(" "),t("tr",[t("td",[n._v("s, n")]),n._v(" "),t("td",[n._v("s: 执行一行源程序代码，如果此行代码中有函数调用，则进入该函数；  \nn: 执行一行源程序代码，此行代码中的函数调用也一并执行。 s 相当于其它调试器中的“Step Into (单步跟踪进入)”；  \nn 相当于其它调试器中的“Step Over (单步跟踪)”。 这两个命令必须在有源代码调试信息的情况下才可以使用（GCC编译时使用“-g”参数）。")]),n._v(" "),t("td",[n._v("(gdb) s  \n(gdb) n")])]),n._v(" "),t("tr",[t("td",[n._v("si, ni")]),n._v(" "),t("td",[n._v("si命令类似于s命令，ni命令类似于n命令。所不同的是，这两个命令（si/ni）所针对的是汇编指令，而s/n针对的是源代码。")]),n._v(" "),t("td",[n._v("(gdb) si  \n(gdb) ni")])]),n._v(" "),t("tr",[t("td",[n._v("p <变量名称></变量名称>")]),n._v(" "),t("td",[n._v("Print的简写，显示指定变量（临时变量或全局变量）的值。")]),n._v(" "),t("td",[n._v("(gdb) p i  \n(gdb) p nGlobalVar")])]),n._v(" "),t("tr",[t("td",[n._v("display ... undisplay <编号></编号>")]),n._v(" "),t("td",[n._v("display，设置程序中断后欲显示的数据及其格式。  \n例如，如果希望每次程序中断后可以看到即将被执行的下一条汇编指令，可以使用命令  \n“display /i $pc”  \n其中 $pc 代表当前汇编指令，/i 表示以十六进行显示。当需要关心汇编代码时，此命令相当有用。 undispaly，取消先前的display设置，编号从1开始递增。")]),n._v(" "),t("td",[n._v("(gdb) display /i $pc (gdb) undisplay 1")])]),n._v(" "),t("tr",[t("td",[n._v("i")]),n._v(" "),t("td",[n._v('[info](#/info "info命令")的简写，用于显示各类信息，详情请查阅“[help](#/help "help命令") i”。')]),n._v(" "),t("td",[n._v("(gdb) i r")])]),n._v(" "),t("tr",[t("td",[n._v("q")]),n._v(" "),t("td",[n._v("Quit的简写，退出GDB调试环境。")]),n._v(" "),t("td",[n._v("(gdb) q")])]),n._v(" "),t("tr",[t("td",[n._v("help [命令名称]")]),n._v(" "),t("td",[n._v("GDB帮助命令，提供对GDB名种命令的解释说明。  \n如果指定了“命令名称”参数，则显示该命令的详细说明；如果没有指定参数，则分类显示所有GDB命令，供用户进一步浏览和查询。")]),n._v(" "),t("td",[n._v("(gdb) help")])])])]),n._v(" "),t("h3",[n._v("语法")]),n._v(" "),t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[n._v("gdb(选项)(参数)\n")])]),n._v(" "),t("h3",[n._v("选项")]),n._v(" "),t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[n._v('-[cd](#/cd "cd命令")：设置工作目录；\n-q：安静模式，不打印介绍信息和版本信息；\n-d：添加文件查找路径；\n-x：从指定文件中执行GDB指令；\n-s：设置读取的符号表文件。\n')])]),n._v(" "),t("h3",[n._v("参数")]),n._v(" "),t("p",[n._v("文件：二进制可执行程序。")]),n._v(" "),t("h3",[n._v("实例")]),n._v(" "),t("p",[n._v("以下是linux下dgb调试的一个实例，先给出一个示例用的小程序，C语言代码：")]),n._v(" "),t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[n._v('#include <stdio.h>\nint nGlobalVar = 0;\n\nint tempFunction(int a, int b)\n{\n    [printf](#/printf "printf命令")("tempFunction is called, a = %d, b = %d /n", a, b);\n    return (a + b);\n}\n\nint main()\n{\n    int n;\n        n = 1;\n        n++;\n        n--;\n\n        nGlobalVar += 100;\n        nGlobalVar -= 12;\n\n    printf("n = %d, nGlobalVar = %d /n", n, nGlobalVar);\n\n        n = tempFunction(1, 2);\n    printf("n = %d", n);\n\n    return 0;\n}\n')])]),n._v(" "),t("p",[n._v("请将此代码复制出来并保存到文件 gdb-sample.c 中，然后切换到此文件所在目录，用GCC编译之：")]),n._v(" "),t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[n._v("gcc gdb-sample.c -o gdb-sample -g\n")])]),n._v(" "),t("p",[n._v("在上面的命令行中，使用 -o 参数指定了编译生成的可执行文件名为 gdb-sample，使用参数 -g 表示将源代码信息编译到可执行文件中。如果不使用参数 -g，会给后面的GDB调试造成不便。当然，如果我们没有程序的源代码，自然也无从使用 -g 参数，调试/跟踪时也只能是汇编代码级别的调试/跟踪。")]),n._v(" "),t("p",[n._v("下面“gdb”命令启动GDB，将首先显示GDB说明，不管它：")]),n._v(" "),t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[n._v('GNU gdb Red Hat Linux (5.3post-0.20021129.18rh)\nCopyright 2003 [free](#/free "free命令") Software Foundation, Inc.\nGDB is free software, covered by the GNU General Public License, and you are\nwelcome to change it and/or distribute copies of it under certain conditions.\n[type](#/type "type命令") "show copying" to see the conditions.\nThere is absolutely no warranty for GDB. Type "show warranty" for details.\nThis GDB was configured [as](#/as "as命令") "i386-redhat-linux-gnu".\n(gdb)\n')])]),n._v(" "),t("p",[n._v("上面最后一行“(gdb)”为GDB内部命令引导符，等待用户输入GDB命令。")]),n._v(" "),t("p",[n._v("下面使用“file”命令载入被调试程序 gdb-sample（这里的 gdb-sample 即前面 GCC 编译输出的可执行文件）：")]),n._v(" "),t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[n._v("(gdb) file gdb-sample\nReading symbols from gdb-sample...done.\n")])]),n._v(" "),t("p",[n._v("上面最后一行提示已经加载成功。")]),n._v(" "),t("p",[n._v("下面使用“r”命令执行（Run）被调试文件，因为尚未设置任何断点，将直接执行到程序结束：")]),n._v(" "),t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[n._v("(gdb) r\nStarting program: /home/liigo/temp/test_jmp/test_jmp/gdb-sample\nn = 1, nGlobalVar = 88\ntempFunction is called, a = 1, b = 2\nn = 3\nProgram exited normally.\n")])]),n._v(" "),t("p",[n._v("下面使用“b”命令在 main 函数开头设置一个断点（Breakpoint）：")]),n._v(" "),t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[n._v('(gdb) b main\nBreakpoint 1 [at](#/at "at命令") 0x804835c: file gdb-sample.c, line 19.\n')])]),n._v(" "),t("p",[n._v("上面最后一行提示已经成功设置断点，并给出了该断点信息：在源文件 gdb-sample.c 第19行处设置断点；这是本程序的第一个断点（序号为1）；断点处的代码地址为 0x804835c（此值可能仅在本次调试过程中有效）。回过头去看源代码，第19行中的代码为“n = 1”，恰好是 main 函数中的第一个可执行语句（前面的“int n;”为变量定义语句，并非可执行语句）。")]),n._v(" "),t("p",[n._v("再次使用“r”命令执行（Run）被调试程序：")]),n._v(" "),t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[n._v("(gdb) r\nStarting program: /home/liigo/temp/gdb-sample\n\nBreakpoint 1, main () at gdb-sample.c:19\n19 n = 1;\n")])]),n._v(" "),t("p",[n._v("程序中断在gdb-sample.c第19行处，即main函数是第一个可执行语句处。")]),n._v(" "),t("p",[n._v("上面最后一行信息为：下一条将要执行的源代码为“n = 1;”，它是源代码文件gdb-sample.c中的第19行。")]),n._v(" "),t("p",[n._v("下面使用“s”命令（Step）执行下一行代码（即第19行“n = 1;”）：")]),n._v(" "),t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[n._v("(gdb) s\n20 n++;\n")])]),n._v(" "),t("p",[n._v("上面的信息表示已经执行完“n = 1;”，并显示下一条要执行的代码为第20行的“n++;”。")]),n._v(" "),t("p",[n._v("既然已经执行了“n = 1;”，即给变量 n 赋值为 1，那我们用“p”命令（Print）看一下变量 n 的值是不是 1 ：")]),n._v(" "),t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[n._v("(gdb) p n\n$1 = 1\n")])]),n._v(" "),t("p",[n._v("果然是 1。（$1大致是表示这是第一次使用“p”命令——再次执行“p n”将显示“$2 = 1”——此信息应该没有什么用处。）")]),n._v(" "),t("p",[n._v("下面我们分别在第26行、tempFunction 函数开头各设置一个断点（分别使用命令“b 26”“b tempFunction”）：")]),n._v(" "),t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[n._v("(gdb) b 26\nBreakpoint 2 at 0x804837b: file gdb-sample.c, line 26.\n(gdb) b tempFunction\nBreakpoint 3 at 0x804832e: file gdb-sample.c, line 12.\n")])]),n._v(" "),t("p",[n._v("使用“c”命令继续（Continue）执行被调试程序，程序将中断在第二 个断点（26行），此时全局变量 nGlobalVar 的值应该是 88；再一次执行“c”命令，程序将中断于第三个断点（12行，tempFunction 函数开头处），此时tempFunction 函数的两个参数 a、b 的值应分别是 1 和 2：")]),n._v(" "),t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[n._v('(gdb) c\nContinuing.\n\nBreakpoint 2, main () at gdb-sample.c:26\n26 printf("n = %d, nGlobalVar = %d /n", n, nGlobalVar);\n(gdb) p nGlobalVar\n$2 = 88\n(gdb) c\nContinuing.\nn = 1, nGlobalVar = 88\n\nBreakpoint 3, tempFunction (a=1, b=2) at gdb-sample.c:12\n12 printf("tempFunction is called, a = %d, b = %d /n", a, b);\n(gdb) p a\n$3 = 1\n(gdb) p b\n$4 = 2\n')])]),n._v(" "),t("p",[n._v("上面反馈的信息一切都在我们预料之中~~")]),n._v(" "),t("p",[n._v("再一次执行“c”命令（Continue），因为后面再也没有其它断点，程序将一直执行到结束：")]),n._v(" "),t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[n._v("(gdb) c\nContinuing.\ntempFunction is called, a = 1, b = 2\nn = 3\nProgram exited normally.\n")])]),n._v(" "),t("p",[n._v("有时候需要看到编译器生成的汇编代码，以进行汇编级的调试或跟踪，又该如何操作呢？")]),n._v(" "),t("p",[n._v("这就要用到display命令“display /i $pc”了（此命令前面已有详细解释）：")]),n._v(" "),t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[n._v("(gdb) display /i $pc\n(gdb)\n")])]),n._v(" "),t("p",[n._v("此后程序再中断时，就可以显示出汇编代码了：")]),n._v(" "),t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[n._v("(gdb) r\nStarting program: /home/liigo/temp/test_jmp/test_jmp/gdb-sample\n\nBreakpoint 1, main () at gdb-sample.c:19\n19 n = 1;\n1: x/i $pc 0x804835c <main+16>: movl $0x1,0xfffffffc(%ebp)\n")])]),n._v(" "),t("p",[n._v("看到了汇编代码，“n = 1;”对应的汇编代码是“movl $0x1,0xfffffffc(%ebp)”。")]),n._v(" "),t("p",[n._v("并且以后程序每次中断都将显示下一条汇编指定（“si”命令用于执行一条汇编代码——区别于“s”执行一行C代码）：")]),n._v(" "),t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[n._v("(gdb) si\n20 n++;\n1: x/i $pc 0x8048363 <main+23>: lea 0xfffffffc(%ebp),%eax\n(gdb) si\n0x08048366 20 n++;\n1: x/i $pc 0x8048366 <main+26>: incl (%eax)\n(gdb) si\n21 n--;\n1: x/i $pc 0x8048368 <main+28>: lea 0xfffffffc(%ebp),%eax\n(gdb) si\n0x0804836b 21 n--;\n1: x/i $pc 0x804836b <main+31>: decl (%eax)\n(gdb) si\n23 nGlobalVar += 100;\n1: x/i $pc 0x804836d <main+33>: addl $0x64,0x80494fc\n")])]),n._v(" "),t("p",[n._v("接下来我们试一下命令“b *<函数名称>”。")]),n._v(" "),t("p",[n._v("为了更简明，有必要先删除目前所有断点（使用“d”命令——Delete breakpoint）：")]),n._v(" "),t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[n._v("(gdb) d\nDelete all breakpoints? (y or n) y\n(gdb)\n")])]),n._v(" "),t("p",[n._v("当被询问是否删除所有断点时，输入“y”并按回车键即可。")]),n._v(" "),t("p",[n._v("下面使用命令“b *main”在 main 函数的 prolog 代码处设置断点（prolog、epilog，分别表示编译器在每个函数的开头和结尾自行插入的代码）：")]),n._v(" "),t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[n._v("(gdb) b *main\nBreakpoint 4 at 0x804834c: file gdb-sample.c, line 17.\n(gdb) r\nThe program being debugged has been started already.\nStart it from the beginning? (y or n) y\nStarting program: /home/liigo/temp/test_jmp/test_jmp/gdb-sample\n\nBreakpoint 4, main () at gdb-sample.c:17\n17 {\n1: x/i $pc 0x804834c <main>: push %ebp\n(gdb) si\n0x0804834d 17 {\n1: x/i $pc 0x804834d <main+1>: mov %esp,%ebp\n(gdb) si\n0x0804834f in main () at gdb-sample.c:17\n17 {\n1: x/i $pc 0x804834f <main+3>: sub $0x8,%esp\n(gdb) si\n0x08048352 17 {\n1: x/i $pc 0x8048352 <main+6>: and $0xfffffff0,%esp\n(gdb) si\n0x08048355 17 {\n1: x/i $pc 0x8048355 <main+9>: mov $0x0,%eax\n(gdb) si\n0x0804835a 17 {\n1: x/i $pc 0x804835a <main+14>: sub %eax,%esp\n(gdb) si\n19 n = 1;\n1: x/i $pc 0x804835c <main+16>: movl $0x1,0xfffffffc(%ebp)\n")])]),n._v(" "),t("p",[n._v("此时可以使用“i r”命令显示寄存器中的当前值———“i r”即“Infomation Register”：")]),n._v(" "),t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[n._v('(gdb) i r\neax 0xbffff6a4 -1073744220\necx 0x42015554 1107383636\nedx 0x40016bc8 1073834952\nebx 0x42130a14 1108544020\nesp 0xbffff6a0 0xbffff6a0\nebp 0xbffff6a8 0xbffff6a8\nesi 0x40015360 1073828704\nedi 0x80483f0 134513648\neip 0x8048366 0x8048366\neflags 0x386 902\ncs 0x23 35\n[ss](#/ss "ss命令") 0x2b 43\nds 0x2b 43\nes 0x2b 43\nfs 0x0 0\ngs 0x33 51\n')])]),n._v(" "),t("p",[n._v("当然也可以显示任意一个指定的寄存器值：")]),n._v(" "),t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[n._v("(gdb) i r eax\neax 0xbffff6a4 -1073744220\n")])]),n._v(" "),t("p",[n._v("最后一个要介绍的命令是“q”，退出（Quit）GDB调试环境：")]),n._v(" "),t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[n._v('(gdb) q\nThe program is running. [exit](#/exit "exit命令") anyway? (y or n)\n')])])])}]}},170:function(n,e,t){n.exports=t(758)},758:function(n,e,t){var p=t(5)(null,t(1213),null,null,null);n.exports=p.exports}});
//# sourceMappingURL=382.f927fa5a94c2d20a6d1e.js.map