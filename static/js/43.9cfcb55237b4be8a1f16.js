webpackJsonp([43],{1103:function(v,_,e){var s=e(5)(null,e(1182),null,null,null);v.exports=s.exports},1182:function(v,_){v.exports={render:function(){var v=this,_=v.$createElement;v._self._c;return v._m(0)},staticRenderFns:[function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("section",[e("p",[e("strong",[v._v("vmstat命令")]),v._v("的含义为显示虚拟内存状态（“Viryual Memor Statics”），但是它可以报告关于进程、内存、I/O等系统整体运行状态。")]),v._v(" "),e("h3",[v._v("语法")]),v._v(" "),e("pre",{pre:!0},[e("code",{attrs:{"v-pre":""}},[v._v("vmstat(选项)(参数)\n")])]),v._v(" "),e("h3",[v._v("选项")]),v._v(" "),e("pre",{pre:!0},[e("code",{attrs:{"v-pre":""}},[v._v("-a：显示活动内页；\n-f：显示启动后创建的进程总数；\n-m：显示slab信息；\n-n：头信息仅显示一次；\n-s：以表格方式显示事件计数器和内存状态；\n-d：报告磁盘状态；\n-p：显示指定的硬盘分区状态；\n-S：输出信息的单位。\n")])]),v._v(" "),e("h3",[v._v("参数")]),v._v(" "),e("ul",[e("li",[v._v("事件间隔：状态信息刷新的时间间隔；")]),v._v(" "),e("li",[v._v("次数：显示报告的次数。")])]),v._v(" "),e("h3",[v._v("实例")]),v._v(" "),e("pre",{pre:!0},[e("code",{attrs:{"v-pre":""}},[v._v('vmstat 3\nprocs -----------memory---------- ---swap-- -----io---- --system-- -----cpu------\n r  b   swpd   [free](#/free "free命令")   buff  cache   si   so    bi    bo   in   cs us sy [id](#/id "id命令") wa st\n 0  0    320  42188 167332 1534368    0    0     4     7    1    0  0  0 99  0  0\n 0  0    320  42188 167332 1534392    0    0     0     0 1002   39  0  0 100  0  0\n 0  0    320  42188 167336 1534392    0    0     0    19 1002   44  0  0 100  0  0\n 0  0    320  42188 167336 1534392    0    0     0     0 1002   41  0  0 100  0  0\n 0  0    320  42188 167336 1534392    0    0     0     0 1002   41  0  0 100  0  0\n\n')])]),v._v(" "),e("p",[e("strong",[v._v("字段说明：")])]),v._v(" "),e("p",[v._v("Procs（进程）")]),v._v(" "),e("ul",[e("li",[v._v("r: 运行队列中进程数量，这个值也可以判断是否需要增加CPU。（长期大于1）")]),v._v(" "),e("li",[v._v("b: 等待IO的进程数量。")])]),v._v(" "),e("p",[v._v("Memory（内存）")]),v._v(" "),e("ul",[e("li",[v._v("swpd: 使用虚拟内存大小，如果swpd的值不为0，但是SI，SO的值长期为0，这种情况不会影响系统性能。")]),v._v(" "),e("li",[v._v("free: 空闲物理内存大小。")]),v._v(" "),e("li",[v._v("buff: 用作缓冲的内存大小。")]),v._v(" "),e("li",[v._v("cache: 用作缓存的内存大小，如果cache的值大的时候，说明cache处的文件数多，如果频繁访问到的文件都能被cache处，那么磁盘的读IO bi会非常小。")])]),v._v(" "),e("p",[v._v("Swap")]),v._v(" "),e("ul",[e("li",[v._v("si: 每秒从交换区写到内存的大小，由磁盘调入内存。")]),v._v(" "),e("li",[v._v("so: 每秒写入交换区的内存大小，由内存调入磁盘。")])]),v._v(" "),e("p",[v._v("注意：内存够用的时候，这2个值都是0，如果这2个值长期大于0时，系统性能会受到影响，磁盘IO和CPU资源都会被消耗。有些朋友看到空闲内存（free）很少的或接近于0时，就认为内存不够用了，不能光看这一点，还要结合si和so，如果free很少，但是si和so也很少（大多时候是0），那么不用担心，系统性能这时不会受到影响的。")]),v._v(" "),e("p",[v._v("IO（现在的Linux版本块的大小为1kb）")]),v._v(" "),e("ul",[e("li",[v._v("bi: 每秒读取的块数")]),v._v(" "),e("li",[v._v("bo: 每秒写入的块数")])]),v._v(" "),e("p",[v._v("注意：随机磁盘读写的时候，这2个值越大（如超出1024k)，能看到CPU在IO等待的值也会越大。")]),v._v(" "),e("p",[v._v("system（系统）")]),v._v(" "),e("ul",[e("li",[v._v("in: 每秒中断数，包括时钟中断。")]),v._v(" "),e("li",[v._v("cs: 每秒上下文切换数。")])]),v._v(" "),e("p",[v._v("注意：上面2个值越大，会看到由内核消耗的CPU时间会越大。")]),v._v(" "),e("p",[v._v("CPU（以百分比表示）")]),v._v(" "),e("ul",[e("li",[v._v("us: 用户进程执行时间百分比(user "),e("a",{attrs:{href:"#/time",title:"time命令"}},[v._v("time")]),v._v(")")])]),v._v(" "),e("p",[v._v("us的值比较高时，说明用户进程消耗的CPU时间多，但是如果长期超50%的使用，那么我们就该考虑优化程序算法或者进行加速。")]),v._v(" "),e("ul",[e("li",[v._v("sy: 内核系统进程执行时间百分比(system time)")])]),v._v(" "),e("p",[v._v("sy的值高时，说明系统内核消耗的CPU资源多，这并不是良性表现，我们应该检查原因。")]),v._v(" "),e("ul",[e("li",[v._v("wa: IO等待时间百分比")])]),v._v(" "),e("p",[v._v("wa的值高时，说明IO等待比较严重，这可能由于磁盘大量作随机访问造成，也有可能磁盘出现瓶颈（块操作）。")]),v._v(" "),e("ul",[e("li",[v._v("id: 空闲时间百分比")])])])}]}},514:function(v,_,e){v.exports=e(1103)}});
//# sourceMappingURL=43.9cfcb55237b4be8a1f16.js.map