{"version":3,"sources":["webpack:///static/js/382.f927fa5a94c2d20a6d1e.js","webpack:///./command/gdb.md?1cdb","webpack:///./command/gdb.md","webpack:///./command/gdb.md?bd05"],"names":["webpackJsonp","1213","module","exports","render","_vm","this","_h","$createElement","_self","_c","_m","staticRenderFns","_v","attrs","href","title","border","cellpadding","cellspacing","pre","v-pre","170","__webpack_require__","758","Component"],"mappings":"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","file":"static/js/382.f927fa5a94c2d20a6d1e.js","sourcesContent":["webpackJsonp([382],{\n\n/***/ 1213:\n/***/ (function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _vm._m(0)\n},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('section', [_c('p', [_c('strong', [_vm._v(\"gdb命令\")]), _vm._v(\"包含在GNU的\"), _c('a', {\n    attrs: {\n      \"href\": \"#/gcc\",\n      \"title\": \"gcc命令\"\n    }\n  }, [_vm._v(\"gcc\")]), _vm._v(\"开发套件中，是功能强大的程序调试器。GDB中的命令固然很多，但我们只需掌握其中十个左右的命令，就大致可以完成日常的基本的程序调试工作。\")]), _vm._v(\" \"), _c('table', {\n    attrs: {\n      \"border\": \"0\",\n      \"cellpadding\": \"0\",\n      \"cellspacing\": \"0\"\n    }\n  }, [_c('tbody', [_c('tr', [_c('th', [_vm._v(\"命令\")]), _vm._v(\" \"), _c('th', [_vm._v(\"解释\")]), _vm._v(\" \"), _c('th', [_vm._v(\"示例\")])]), _vm._v(\" \"), _c('tr', [_c('td', [_vm._v(\"[file](#/file \\\"file命令\\\") <文件名></文件名>\")]), _vm._v(\" \"), _c('td', [_vm._v(\"加载被调试的可执行程序文件。  \\n因为一般都在被调试程序所在目录下执行GDB，因而文本名不需要带路径。\")]), _vm._v(\" \"), _c('td', [_vm._v(\"(gdb) file gdb-sample\")])]), _vm._v(\" \"), _c('tr', [_c('td', [_vm._v(\"r\")]), _vm._v(\" \"), _c('td', [_vm._v(\"Run的简写，运行被调试的程序。  \\n如果此前没有下过断点，则执行完整个程序；如果有断点，则程序暂停在第一个可用断点处。\")]), _vm._v(\" \"), _c('td', [_vm._v(\"(gdb) r\")])]), _vm._v(\" \"), _c('tr', [_c('td', [_vm._v(\"c\")]), _vm._v(\" \"), _c('td', [_vm._v(\"Continue的简写，继续执行被调试程序，直至下一个断点或程序结束。\")]), _vm._v(\" \"), _c('td', [_vm._v(\"(gdb) c\")])]), _vm._v(\" \"), _c('tr', [_c('td', [_vm._v(\"b <行号>  \\nb <函数名称>  \\nb *<函数名称>  \\nb *<代码地址> d [编号]</代码地址></函数名称></函数名称></行号>\")]), _vm._v(\" \"), _c('td', [_vm._v(\"b: Breakpoint的简写，设置断点。两可以使用“行号”“函数名称”“执行地址”等方式指定断点位置。  \\n其中在函数名称前面加“*”符号表示将断点设置在“由编译器生成的prolog代码处”。如果不了解汇编，可以不予理会此用法。 d: Delete breakpoint的简写，删除指定编号的某个断点，或删除所有断点。断点编号从1开始递增。\")]), _vm._v(\" \"), _c('td', [_vm._v(\"(gdb) b 8  \\n(gdb) b main  \\n(gdb) b *main  \\n(gdb) b *0x804835c (gdb) d\")])]), _vm._v(\" \"), _c('tr', [_c('td', [_vm._v(\"s, n\")]), _vm._v(\" \"), _c('td', [_vm._v(\"s: 执行一行源程序代码，如果此行代码中有函数调用，则进入该函数；  \\nn: 执行一行源程序代码，此行代码中的函数调用也一并执行。 s 相当于其它调试器中的“Step Into (单步跟踪进入)”；  \\nn 相当于其它调试器中的“Step Over (单步跟踪)”。 这两个命令必须在有源代码调试信息的情况下才可以使用（GCC编译时使用“-g”参数）。\")]), _vm._v(\" \"), _c('td', [_vm._v(\"(gdb) s  \\n(gdb) n\")])]), _vm._v(\" \"), _c('tr', [_c('td', [_vm._v(\"si, ni\")]), _vm._v(\" \"), _c('td', [_vm._v(\"si命令类似于s命令，ni命令类似于n命令。所不同的是，这两个命令（si/ni）所针对的是汇编指令，而s/n针对的是源代码。\")]), _vm._v(\" \"), _c('td', [_vm._v(\"(gdb) si  \\n(gdb) ni\")])]), _vm._v(\" \"), _c('tr', [_c('td', [_vm._v(\"p <变量名称></变量名称>\")]), _vm._v(\" \"), _c('td', [_vm._v(\"Print的简写，显示指定变量（临时变量或全局变量）的值。\")]), _vm._v(\" \"), _c('td', [_vm._v(\"(gdb) p i  \\n(gdb) p nGlobalVar\")])]), _vm._v(\" \"), _c('tr', [_c('td', [_vm._v(\"display ... undisplay <编号></编号>\")]), _vm._v(\" \"), _c('td', [_vm._v(\"display，设置程序中断后欲显示的数据及其格式。  \\n例如，如果希望每次程序中断后可以看到即将被执行的下一条汇编指令，可以使用命令  \\n“display /i $pc”  \\n其中 $pc 代表当前汇编指令，/i 表示以十六进行显示。当需要关心汇编代码时，此命令相当有用。 undispaly，取消先前的display设置，编号从1开始递增。\")]), _vm._v(\" \"), _c('td', [_vm._v(\"(gdb) display /i $pc (gdb) undisplay 1\")])]), _vm._v(\" \"), _c('tr', [_c('td', [_vm._v(\"i\")]), _vm._v(\" \"), _c('td', [_vm._v(\"[info](#/info \\\"info命令\\\")的简写，用于显示各类信息，详情请查阅“[help](#/help \\\"help命令\\\") i”。\")]), _vm._v(\" \"), _c('td', [_vm._v(\"(gdb) i r\")])]), _vm._v(\" \"), _c('tr', [_c('td', [_vm._v(\"q\")]), _vm._v(\" \"), _c('td', [_vm._v(\"Quit的简写，退出GDB调试环境。\")]), _vm._v(\" \"), _c('td', [_vm._v(\"(gdb) q\")])]), _vm._v(\" \"), _c('tr', [_c('td', [_vm._v(\"help [命令名称]\")]), _vm._v(\" \"), _c('td', [_vm._v(\"GDB帮助命令，提供对GDB名种命令的解释说明。  \\n如果指定了“命令名称”参数，则显示该命令的详细说明；如果没有指定参数，则分类显示所有GDB命令，供用户进一步浏览和查询。\")]), _vm._v(\" \"), _c('td', [_vm._v(\"(gdb) help\")])])])]), _vm._v(\" \"), _c('h3', [_vm._v(\"语法\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"gdb(选项)(参数)\\n\")])]), _vm._v(\" \"), _c('h3', [_vm._v(\"选项\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"-[cd](#/cd \\\"cd命令\\\")：设置工作目录；\\n-q：安静模式，不打印介绍信息和版本信息；\\n-d：添加文件查找路径；\\n-x：从指定文件中执行GDB指令；\\n-s：设置读取的符号表文件。\\n\")])]), _vm._v(\" \"), _c('h3', [_vm._v(\"参数\")]), _vm._v(\" \"), _c('p', [_vm._v(\"文件：二进制可执行程序。\")]), _vm._v(\" \"), _c('h3', [_vm._v(\"实例\")]), _vm._v(\" \"), _c('p', [_vm._v(\"以下是linux下dgb调试的一个实例，先给出一个示例用的小程序，C语言代码：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"#include <stdio.h>\\nint nGlobalVar = 0;\\n\\nint tempFunction(int a, int b)\\n{\\n    [printf](#/printf \\\"printf命令\\\")(\\\"tempFunction is called, a = %d, b = %d /n\\\", a, b);\\n    return (a + b);\\n}\\n\\nint main()\\n{\\n    int n;\\n        n = 1;\\n        n++;\\n        n--;\\n\\n        nGlobalVar += 100;\\n        nGlobalVar -= 12;\\n\\n    printf(\\\"n = %d, nGlobalVar = %d /n\\\", n, nGlobalVar);\\n\\n        n = tempFunction(1, 2);\\n    printf(\\\"n = %d\\\", n);\\n\\n    return 0;\\n}\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"请将此代码复制出来并保存到文件 gdb-sample.c 中，然后切换到此文件所在目录，用GCC编译之：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"gcc gdb-sample.c -o gdb-sample -g\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"在上面的命令行中，使用 -o 参数指定了编译生成的可执行文件名为 gdb-sample，使用参数 -g 表示将源代码信息编译到可执行文件中。如果不使用参数 -g，会给后面的GDB调试造成不便。当然，如果我们没有程序的源代码，自然也无从使用 -g 参数，调试/跟踪时也只能是汇编代码级别的调试/跟踪。\")]), _vm._v(\" \"), _c('p', [_vm._v(\"下面“gdb”命令启动GDB，将首先显示GDB说明，不管它：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"GNU gdb Red Hat Linux (5.3post-0.20021129.18rh)\\nCopyright 2003 [free](#/free \\\"free命令\\\") Software Foundation, Inc.\\nGDB is free software, covered by the GNU General Public License, and you are\\nwelcome to change it and/or distribute copies of it under certain conditions.\\n[type](#/type \\\"type命令\\\") \\\"show copying\\\" to see the conditions.\\nThere is absolutely no warranty for GDB. Type \\\"show warranty\\\" for details.\\nThis GDB was configured [as](#/as \\\"as命令\\\") \\\"i386-redhat-linux-gnu\\\".\\n(gdb)\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"上面最后一行“(gdb)”为GDB内部命令引导符，等待用户输入GDB命令。\")]), _vm._v(\" \"), _c('p', [_vm._v(\"下面使用“file”命令载入被调试程序 gdb-sample（这里的 gdb-sample 即前面 GCC 编译输出的可执行文件）：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"(gdb) file gdb-sample\\nReading symbols from gdb-sample...done.\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"上面最后一行提示已经加载成功。\")]), _vm._v(\" \"), _c('p', [_vm._v(\"下面使用“r”命令执行（Run）被调试文件，因为尚未设置任何断点，将直接执行到程序结束：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"(gdb) r\\nStarting program: /home/liigo/temp/test_jmp/test_jmp/gdb-sample\\nn = 1, nGlobalVar = 88\\ntempFunction is called, a = 1, b = 2\\nn = 3\\nProgram exited normally.\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"下面使用“b”命令在 main 函数开头设置一个断点（Breakpoint）：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"(gdb) b main\\nBreakpoint 1 [at](#/at \\\"at命令\\\") 0x804835c: file gdb-sample.c, line 19.\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"上面最后一行提示已经成功设置断点，并给出了该断点信息：在源文件 gdb-sample.c 第19行处设置断点；这是本程序的第一个断点（序号为1）；断点处的代码地址为 0x804835c（此值可能仅在本次调试过程中有效）。回过头去看源代码，第19行中的代码为“n = 1”，恰好是 main 函数中的第一个可执行语句（前面的“int n;”为变量定义语句，并非可执行语句）。\")]), _vm._v(\" \"), _c('p', [_vm._v(\"再次使用“r”命令执行（Run）被调试程序：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"(gdb) r\\nStarting program: /home/liigo/temp/gdb-sample\\n\\nBreakpoint 1, main () at gdb-sample.c:19\\n19 n = 1;\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"程序中断在gdb-sample.c第19行处，即main函数是第一个可执行语句处。\")]), _vm._v(\" \"), _c('p', [_vm._v(\"上面最后一行信息为：下一条将要执行的源代码为“n = 1;”，它是源代码文件gdb-sample.c中的第19行。\")]), _vm._v(\" \"), _c('p', [_vm._v(\"下面使用“s”命令（Step）执行下一行代码（即第19行“n = 1;”）：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"(gdb) s\\n20 n++;\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"上面的信息表示已经执行完“n = 1;”，并显示下一条要执行的代码为第20行的“n++;”。\")]), _vm._v(\" \"), _c('p', [_vm._v(\"既然已经执行了“n = 1;”，即给变量 n 赋值为 1，那我们用“p”命令（Print）看一下变量 n 的值是不是 1 ：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"(gdb) p n\\n$1 = 1\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"果然是 1。（$1大致是表示这是第一次使用“p”命令——再次执行“p n”将显示“$2 = 1”——此信息应该没有什么用处。）\")]), _vm._v(\" \"), _c('p', [_vm._v(\"下面我们分别在第26行、tempFunction 函数开头各设置一个断点（分别使用命令“b 26”“b tempFunction”）：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"(gdb) b 26\\nBreakpoint 2 at 0x804837b: file gdb-sample.c, line 26.\\n(gdb) b tempFunction\\nBreakpoint 3 at 0x804832e: file gdb-sample.c, line 12.\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"使用“c”命令继续（Continue）执行被调试程序，程序将中断在第二 个断点（26行），此时全局变量 nGlobalVar 的值应该是 88；再一次执行“c”命令，程序将中断于第三个断点（12行，tempFunction 函数开头处），此时tempFunction 函数的两个参数 a、b 的值应分别是 1 和 2：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"(gdb) c\\nContinuing.\\n\\nBreakpoint 2, main () at gdb-sample.c:26\\n26 printf(\\\"n = %d, nGlobalVar = %d /n\\\", n, nGlobalVar);\\n(gdb) p nGlobalVar\\n$2 = 88\\n(gdb) c\\nContinuing.\\nn = 1, nGlobalVar = 88\\n\\nBreakpoint 3, tempFunction (a=1, b=2) at gdb-sample.c:12\\n12 printf(\\\"tempFunction is called, a = %d, b = %d /n\\\", a, b);\\n(gdb) p a\\n$3 = 1\\n(gdb) p b\\n$4 = 2\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"上面反馈的信息一切都在我们预料之中~~\")]), _vm._v(\" \"), _c('p', [_vm._v(\"再一次执行“c”命令（Continue），因为后面再也没有其它断点，程序将一直执行到结束：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"(gdb) c\\nContinuing.\\ntempFunction is called, a = 1, b = 2\\nn = 3\\nProgram exited normally.\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"有时候需要看到编译器生成的汇编代码，以进行汇编级的调试或跟踪，又该如何操作呢？\")]), _vm._v(\" \"), _c('p', [_vm._v(\"这就要用到display命令“display /i $pc”了（此命令前面已有详细解释）：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"(gdb) display /i $pc\\n(gdb)\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"此后程序再中断时，就可以显示出汇编代码了：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"(gdb) r\\nStarting program: /home/liigo/temp/test_jmp/test_jmp/gdb-sample\\n\\nBreakpoint 1, main () at gdb-sample.c:19\\n19 n = 1;\\n1: x/i $pc 0x804835c <main+16>: movl $0x1,0xfffffffc(%ebp)\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"看到了汇编代码，“n = 1;”对应的汇编代码是“movl $0x1,0xfffffffc(%ebp)”。\")]), _vm._v(\" \"), _c('p', [_vm._v(\"并且以后程序每次中断都将显示下一条汇编指定（“si”命令用于执行一条汇编代码——区别于“s”执行一行C代码）：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"(gdb) si\\n20 n++;\\n1: x/i $pc 0x8048363 <main+23>: lea 0xfffffffc(%ebp),%eax\\n(gdb) si\\n0x08048366 20 n++;\\n1: x/i $pc 0x8048366 <main+26>: incl (%eax)\\n(gdb) si\\n21 n--;\\n1: x/i $pc 0x8048368 <main+28>: lea 0xfffffffc(%ebp),%eax\\n(gdb) si\\n0x0804836b 21 n--;\\n1: x/i $pc 0x804836b <main+31>: decl (%eax)\\n(gdb) si\\n23 nGlobalVar += 100;\\n1: x/i $pc 0x804836d <main+33>: addl $0x64,0x80494fc\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"接下来我们试一下命令“b *<函数名称>”。\")]), _vm._v(\" \"), _c('p', [_vm._v(\"为了更简明，有必要先删除目前所有断点（使用“d”命令——Delete breakpoint）：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"(gdb) d\\nDelete all breakpoints? (y or n) y\\n(gdb)\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"当被询问是否删除所有断点时，输入“y”并按回车键即可。\")]), _vm._v(\" \"), _c('p', [_vm._v(\"下面使用命令“b *main”在 main 函数的 prolog 代码处设置断点（prolog、epilog，分别表示编译器在每个函数的开头和结尾自行插入的代码）：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"(gdb) b *main\\nBreakpoint 4 at 0x804834c: file gdb-sample.c, line 17.\\n(gdb) r\\nThe program being debugged has been started already.\\nStart it from the beginning? (y or n) y\\nStarting program: /home/liigo/temp/test_jmp/test_jmp/gdb-sample\\n\\nBreakpoint 4, main () at gdb-sample.c:17\\n17 {\\n1: x/i $pc 0x804834c <main>: push %ebp\\n(gdb) si\\n0x0804834d 17 {\\n1: x/i $pc 0x804834d <main+1>: mov %esp,%ebp\\n(gdb) si\\n0x0804834f in main () at gdb-sample.c:17\\n17 {\\n1: x/i $pc 0x804834f <main+3>: sub $0x8,%esp\\n(gdb) si\\n0x08048352 17 {\\n1: x/i $pc 0x8048352 <main+6>: and $0xfffffff0,%esp\\n(gdb) si\\n0x08048355 17 {\\n1: x/i $pc 0x8048355 <main+9>: mov $0x0,%eax\\n(gdb) si\\n0x0804835a 17 {\\n1: x/i $pc 0x804835a <main+14>: sub %eax,%esp\\n(gdb) si\\n19 n = 1;\\n1: x/i $pc 0x804835c <main+16>: movl $0x1,0xfffffffc(%ebp)\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"此时可以使用“i r”命令显示寄存器中的当前值———“i r”即“Infomation Register”：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"(gdb) i r\\neax 0xbffff6a4 -1073744220\\necx 0x42015554 1107383636\\nedx 0x40016bc8 1073834952\\nebx 0x42130a14 1108544020\\nesp 0xbffff6a0 0xbffff6a0\\nebp 0xbffff6a8 0xbffff6a8\\nesi 0x40015360 1073828704\\nedi 0x80483f0 134513648\\neip 0x8048366 0x8048366\\neflags 0x386 902\\ncs 0x23 35\\n[ss](#/ss \\\"ss命令\\\") 0x2b 43\\nds 0x2b 43\\nes 0x2b 43\\nfs 0x0 0\\ngs 0x33 51\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"当然也可以显示任意一个指定的寄存器值：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"(gdb) i r eax\\neax 0xbffff6a4 -1073744220\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"最后一个要介绍的命令是“q”，退出（Quit）GDB调试环境：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"(gdb) q\\nThe program is running. [exit](#/exit \\\"exit命令\\\") anyway? (y or n)\\n\")])])])\n}]}\n\n/***/ }),\n\n/***/ 170:\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(758);\n\n/***/ }),\n\n/***/ 758:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Component = __webpack_require__(5)(\n  /* script */\n  null,\n  /* template */\n  __webpack_require__(1213),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/382.f927fa5a94c2d20a6d1e.js","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _vm._m(0)\n},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('section', [_c('p', [_c('strong', [_vm._v(\"gdb命令\")]), _vm._v(\"包含在GNU的\"), _c('a', {\n    attrs: {\n      \"href\": \"#/gcc\",\n      \"title\": \"gcc命令\"\n    }\n  }, [_vm._v(\"gcc\")]), _vm._v(\"开发套件中，是功能强大的程序调试器。GDB中的命令固然很多，但我们只需掌握其中十个左右的命令，就大致可以完成日常的基本的程序调试工作。\")]), _vm._v(\" \"), _c('table', {\n    attrs: {\n      \"border\": \"0\",\n      \"cellpadding\": \"0\",\n      \"cellspacing\": \"0\"\n    }\n  }, [_c('tbody', [_c('tr', [_c('th', [_vm._v(\"命令\")]), _vm._v(\" \"), _c('th', [_vm._v(\"解释\")]), _vm._v(\" \"), _c('th', [_vm._v(\"示例\")])]), _vm._v(\" \"), _c('tr', [_c('td', [_vm._v(\"[file](#/file \\\"file命令\\\") <文件名></文件名>\")]), _vm._v(\" \"), _c('td', [_vm._v(\"加载被调试的可执行程序文件。  \\n因为一般都在被调试程序所在目录下执行GDB，因而文本名不需要带路径。\")]), _vm._v(\" \"), _c('td', [_vm._v(\"(gdb) file gdb-sample\")])]), _vm._v(\" \"), _c('tr', [_c('td', [_vm._v(\"r\")]), _vm._v(\" \"), _c('td', [_vm._v(\"Run的简写，运行被调试的程序。  \\n如果此前没有下过断点，则执行完整个程序；如果有断点，则程序暂停在第一个可用断点处。\")]), _vm._v(\" \"), _c('td', [_vm._v(\"(gdb) r\")])]), _vm._v(\" \"), _c('tr', [_c('td', [_vm._v(\"c\")]), _vm._v(\" \"), _c('td', [_vm._v(\"Continue的简写，继续执行被调试程序，直至下一个断点或程序结束。\")]), _vm._v(\" \"), _c('td', [_vm._v(\"(gdb) c\")])]), _vm._v(\" \"), _c('tr', [_c('td', [_vm._v(\"b <行号>  \\nb <函数名称>  \\nb *<函数名称>  \\nb *<代码地址> d [编号]</代码地址></函数名称></函数名称></行号>\")]), _vm._v(\" \"), _c('td', [_vm._v(\"b: Breakpoint的简写，设置断点。两可以使用“行号”“函数名称”“执行地址”等方式指定断点位置。  \\n其中在函数名称前面加“*”符号表示将断点设置在“由编译器生成的prolog代码处”。如果不了解汇编，可以不予理会此用法。 d: Delete breakpoint的简写，删除指定编号的某个断点，或删除所有断点。断点编号从1开始递增。\")]), _vm._v(\" \"), _c('td', [_vm._v(\"(gdb) b 8  \\n(gdb) b main  \\n(gdb) b *main  \\n(gdb) b *0x804835c (gdb) d\")])]), _vm._v(\" \"), _c('tr', [_c('td', [_vm._v(\"s, n\")]), _vm._v(\" \"), _c('td', [_vm._v(\"s: 执行一行源程序代码，如果此行代码中有函数调用，则进入该函数；  \\nn: 执行一行源程序代码，此行代码中的函数调用也一并执行。 s 相当于其它调试器中的“Step Into (单步跟踪进入)”；  \\nn 相当于其它调试器中的“Step Over (单步跟踪)”。 这两个命令必须在有源代码调试信息的情况下才可以使用（GCC编译时使用“-g”参数）。\")]), _vm._v(\" \"), _c('td', [_vm._v(\"(gdb) s  \\n(gdb) n\")])]), _vm._v(\" \"), _c('tr', [_c('td', [_vm._v(\"si, ni\")]), _vm._v(\" \"), _c('td', [_vm._v(\"si命令类似于s命令，ni命令类似于n命令。所不同的是，这两个命令（si/ni）所针对的是汇编指令，而s/n针对的是源代码。\")]), _vm._v(\" \"), _c('td', [_vm._v(\"(gdb) si  \\n(gdb) ni\")])]), _vm._v(\" \"), _c('tr', [_c('td', [_vm._v(\"p <变量名称></变量名称>\")]), _vm._v(\" \"), _c('td', [_vm._v(\"Print的简写，显示指定变量（临时变量或全局变量）的值。\")]), _vm._v(\" \"), _c('td', [_vm._v(\"(gdb) p i  \\n(gdb) p nGlobalVar\")])]), _vm._v(\" \"), _c('tr', [_c('td', [_vm._v(\"display ... undisplay <编号></编号>\")]), _vm._v(\" \"), _c('td', [_vm._v(\"display，设置程序中断后欲显示的数据及其格式。  \\n例如，如果希望每次程序中断后可以看到即将被执行的下一条汇编指令，可以使用命令  \\n“display /i $pc”  \\n其中 $pc 代表当前汇编指令，/i 表示以十六进行显示。当需要关心汇编代码时，此命令相当有用。 undispaly，取消先前的display设置，编号从1开始递增。\")]), _vm._v(\" \"), _c('td', [_vm._v(\"(gdb) display /i $pc (gdb) undisplay 1\")])]), _vm._v(\" \"), _c('tr', [_c('td', [_vm._v(\"i\")]), _vm._v(\" \"), _c('td', [_vm._v(\"[info](#/info \\\"info命令\\\")的简写，用于显示各类信息，详情请查阅“[help](#/help \\\"help命令\\\") i”。\")]), _vm._v(\" \"), _c('td', [_vm._v(\"(gdb) i r\")])]), _vm._v(\" \"), _c('tr', [_c('td', [_vm._v(\"q\")]), _vm._v(\" \"), _c('td', [_vm._v(\"Quit的简写，退出GDB调试环境。\")]), _vm._v(\" \"), _c('td', [_vm._v(\"(gdb) q\")])]), _vm._v(\" \"), _c('tr', [_c('td', [_vm._v(\"help [命令名称]\")]), _vm._v(\" \"), _c('td', [_vm._v(\"GDB帮助命令，提供对GDB名种命令的解释说明。  \\n如果指定了“命令名称”参数，则显示该命令的详细说明；如果没有指定参数，则分类显示所有GDB命令，供用户进一步浏览和查询。\")]), _vm._v(\" \"), _c('td', [_vm._v(\"(gdb) help\")])])])]), _vm._v(\" \"), _c('h3', [_vm._v(\"语法\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"gdb(选项)(参数)\\n\")])]), _vm._v(\" \"), _c('h3', [_vm._v(\"选项\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"-[cd](#/cd \\\"cd命令\\\")：设置工作目录；\\n-q：安静模式，不打印介绍信息和版本信息；\\n-d：添加文件查找路径；\\n-x：从指定文件中执行GDB指令；\\n-s：设置读取的符号表文件。\\n\")])]), _vm._v(\" \"), _c('h3', [_vm._v(\"参数\")]), _vm._v(\" \"), _c('p', [_vm._v(\"文件：二进制可执行程序。\")]), _vm._v(\" \"), _c('h3', [_vm._v(\"实例\")]), _vm._v(\" \"), _c('p', [_vm._v(\"以下是linux下dgb调试的一个实例，先给出一个示例用的小程序，C语言代码：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"#include <stdio.h>\\nint nGlobalVar = 0;\\n\\nint tempFunction(int a, int b)\\n{\\n    [printf](#/printf \\\"printf命令\\\")(\\\"tempFunction is called, a = %d, b = %d /n\\\", a, b);\\n    return (a + b);\\n}\\n\\nint main()\\n{\\n    int n;\\n        n = 1;\\n        n++;\\n        n--;\\n\\n        nGlobalVar += 100;\\n        nGlobalVar -= 12;\\n\\n    printf(\\\"n = %d, nGlobalVar = %d /n\\\", n, nGlobalVar);\\n\\n        n = tempFunction(1, 2);\\n    printf(\\\"n = %d\\\", n);\\n\\n    return 0;\\n}\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"请将此代码复制出来并保存到文件 gdb-sample.c 中，然后切换到此文件所在目录，用GCC编译之：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"gcc gdb-sample.c -o gdb-sample -g\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"在上面的命令行中，使用 -o 参数指定了编译生成的可执行文件名为 gdb-sample，使用参数 -g 表示将源代码信息编译到可执行文件中。如果不使用参数 -g，会给后面的GDB调试造成不便。当然，如果我们没有程序的源代码，自然也无从使用 -g 参数，调试/跟踪时也只能是汇编代码级别的调试/跟踪。\")]), _vm._v(\" \"), _c('p', [_vm._v(\"下面“gdb”命令启动GDB，将首先显示GDB说明，不管它：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"GNU gdb Red Hat Linux (5.3post-0.20021129.18rh)\\nCopyright 2003 [free](#/free \\\"free命令\\\") Software Foundation, Inc.\\nGDB is free software, covered by the GNU General Public License, and you are\\nwelcome to change it and/or distribute copies of it under certain conditions.\\n[type](#/type \\\"type命令\\\") \\\"show copying\\\" to see the conditions.\\nThere is absolutely no warranty for GDB. Type \\\"show warranty\\\" for details.\\nThis GDB was configured [as](#/as \\\"as命令\\\") \\\"i386-redhat-linux-gnu\\\".\\n(gdb)\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"上面最后一行“(gdb)”为GDB内部命令引导符，等待用户输入GDB命令。\")]), _vm._v(\" \"), _c('p', [_vm._v(\"下面使用“file”命令载入被调试程序 gdb-sample（这里的 gdb-sample 即前面 GCC 编译输出的可执行文件）：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"(gdb) file gdb-sample\\nReading symbols from gdb-sample...done.\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"上面最后一行提示已经加载成功。\")]), _vm._v(\" \"), _c('p', [_vm._v(\"下面使用“r”命令执行（Run）被调试文件，因为尚未设置任何断点，将直接执行到程序结束：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"(gdb) r\\nStarting program: /home/liigo/temp/test_jmp/test_jmp/gdb-sample\\nn = 1, nGlobalVar = 88\\ntempFunction is called, a = 1, b = 2\\nn = 3\\nProgram exited normally.\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"下面使用“b”命令在 main 函数开头设置一个断点（Breakpoint）：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"(gdb) b main\\nBreakpoint 1 [at](#/at \\\"at命令\\\") 0x804835c: file gdb-sample.c, line 19.\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"上面最后一行提示已经成功设置断点，并给出了该断点信息：在源文件 gdb-sample.c 第19行处设置断点；这是本程序的第一个断点（序号为1）；断点处的代码地址为 0x804835c（此值可能仅在本次调试过程中有效）。回过头去看源代码，第19行中的代码为“n = 1”，恰好是 main 函数中的第一个可执行语句（前面的“int n;”为变量定义语句，并非可执行语句）。\")]), _vm._v(\" \"), _c('p', [_vm._v(\"再次使用“r”命令执行（Run）被调试程序：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"(gdb) r\\nStarting program: /home/liigo/temp/gdb-sample\\n\\nBreakpoint 1, main () at gdb-sample.c:19\\n19 n = 1;\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"程序中断在gdb-sample.c第19行处，即main函数是第一个可执行语句处。\")]), _vm._v(\" \"), _c('p', [_vm._v(\"上面最后一行信息为：下一条将要执行的源代码为“n = 1;”，它是源代码文件gdb-sample.c中的第19行。\")]), _vm._v(\" \"), _c('p', [_vm._v(\"下面使用“s”命令（Step）执行下一行代码（即第19行“n = 1;”）：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"(gdb) s\\n20 n++;\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"上面的信息表示已经执行完“n = 1;”，并显示下一条要执行的代码为第20行的“n++;”。\")]), _vm._v(\" \"), _c('p', [_vm._v(\"既然已经执行了“n = 1;”，即给变量 n 赋值为 1，那我们用“p”命令（Print）看一下变量 n 的值是不是 1 ：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"(gdb) p n\\n$1 = 1\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"果然是 1。（$1大致是表示这是第一次使用“p”命令——再次执行“p n”将显示“$2 = 1”——此信息应该没有什么用处。）\")]), _vm._v(\" \"), _c('p', [_vm._v(\"下面我们分别在第26行、tempFunction 函数开头各设置一个断点（分别使用命令“b 26”“b tempFunction”）：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"(gdb) b 26\\nBreakpoint 2 at 0x804837b: file gdb-sample.c, line 26.\\n(gdb) b tempFunction\\nBreakpoint 3 at 0x804832e: file gdb-sample.c, line 12.\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"使用“c”命令继续（Continue）执行被调试程序，程序将中断在第二 个断点（26行），此时全局变量 nGlobalVar 的值应该是 88；再一次执行“c”命令，程序将中断于第三个断点（12行，tempFunction 函数开头处），此时tempFunction 函数的两个参数 a、b 的值应分别是 1 和 2：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"(gdb) c\\nContinuing.\\n\\nBreakpoint 2, main () at gdb-sample.c:26\\n26 printf(\\\"n = %d, nGlobalVar = %d /n\\\", n, nGlobalVar);\\n(gdb) p nGlobalVar\\n$2 = 88\\n(gdb) c\\nContinuing.\\nn = 1, nGlobalVar = 88\\n\\nBreakpoint 3, tempFunction (a=1, b=2) at gdb-sample.c:12\\n12 printf(\\\"tempFunction is called, a = %d, b = %d /n\\\", a, b);\\n(gdb) p a\\n$3 = 1\\n(gdb) p b\\n$4 = 2\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"上面反馈的信息一切都在我们预料之中~~\")]), _vm._v(\" \"), _c('p', [_vm._v(\"再一次执行“c”命令（Continue），因为后面再也没有其它断点，程序将一直执行到结束：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"(gdb) c\\nContinuing.\\ntempFunction is called, a = 1, b = 2\\nn = 3\\nProgram exited normally.\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"有时候需要看到编译器生成的汇编代码，以进行汇编级的调试或跟踪，又该如何操作呢？\")]), _vm._v(\" \"), _c('p', [_vm._v(\"这就要用到display命令“display /i $pc”了（此命令前面已有详细解释）：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"(gdb) display /i $pc\\n(gdb)\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"此后程序再中断时，就可以显示出汇编代码了：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"(gdb) r\\nStarting program: /home/liigo/temp/test_jmp/test_jmp/gdb-sample\\n\\nBreakpoint 1, main () at gdb-sample.c:19\\n19 n = 1;\\n1: x/i $pc 0x804835c <main+16>: movl $0x1,0xfffffffc(%ebp)\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"看到了汇编代码，“n = 1;”对应的汇编代码是“movl $0x1,0xfffffffc(%ebp)”。\")]), _vm._v(\" \"), _c('p', [_vm._v(\"并且以后程序每次中断都将显示下一条汇编指定（“si”命令用于执行一条汇编代码——区别于“s”执行一行C代码）：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"(gdb) si\\n20 n++;\\n1: x/i $pc 0x8048363 <main+23>: lea 0xfffffffc(%ebp),%eax\\n(gdb) si\\n0x08048366 20 n++;\\n1: x/i $pc 0x8048366 <main+26>: incl (%eax)\\n(gdb) si\\n21 n--;\\n1: x/i $pc 0x8048368 <main+28>: lea 0xfffffffc(%ebp),%eax\\n(gdb) si\\n0x0804836b 21 n--;\\n1: x/i $pc 0x804836b <main+31>: decl (%eax)\\n(gdb) si\\n23 nGlobalVar += 100;\\n1: x/i $pc 0x804836d <main+33>: addl $0x64,0x80494fc\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"接下来我们试一下命令“b *<函数名称>”。\")]), _vm._v(\" \"), _c('p', [_vm._v(\"为了更简明，有必要先删除目前所有断点（使用“d”命令——Delete breakpoint）：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"(gdb) d\\nDelete all breakpoints? (y or n) y\\n(gdb)\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"当被询问是否删除所有断点时，输入“y”并按回车键即可。\")]), _vm._v(\" \"), _c('p', [_vm._v(\"下面使用命令“b *main”在 main 函数的 prolog 代码处设置断点（prolog、epilog，分别表示编译器在每个函数的开头和结尾自行插入的代码）：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"(gdb) b *main\\nBreakpoint 4 at 0x804834c: file gdb-sample.c, line 17.\\n(gdb) r\\nThe program being debugged has been started already.\\nStart it from the beginning? (y or n) y\\nStarting program: /home/liigo/temp/test_jmp/test_jmp/gdb-sample\\n\\nBreakpoint 4, main () at gdb-sample.c:17\\n17 {\\n1: x/i $pc 0x804834c <main>: push %ebp\\n(gdb) si\\n0x0804834d 17 {\\n1: x/i $pc 0x804834d <main+1>: mov %esp,%ebp\\n(gdb) si\\n0x0804834f in main () at gdb-sample.c:17\\n17 {\\n1: x/i $pc 0x804834f <main+3>: sub $0x8,%esp\\n(gdb) si\\n0x08048352 17 {\\n1: x/i $pc 0x8048352 <main+6>: and $0xfffffff0,%esp\\n(gdb) si\\n0x08048355 17 {\\n1: x/i $pc 0x8048355 <main+9>: mov $0x0,%eax\\n(gdb) si\\n0x0804835a 17 {\\n1: x/i $pc 0x804835a <main+14>: sub %eax,%esp\\n(gdb) si\\n19 n = 1;\\n1: x/i $pc 0x804835c <main+16>: movl $0x1,0xfffffffc(%ebp)\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"此时可以使用“i r”命令显示寄存器中的当前值———“i r”即“Infomation Register”：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"(gdb) i r\\neax 0xbffff6a4 -1073744220\\necx 0x42015554 1107383636\\nedx 0x40016bc8 1073834952\\nebx 0x42130a14 1108544020\\nesp 0xbffff6a0 0xbffff6a0\\nebp 0xbffff6a8 0xbffff6a8\\nesi 0x40015360 1073828704\\nedi 0x80483f0 134513648\\neip 0x8048366 0x8048366\\neflags 0x386 902\\ncs 0x23 35\\n[ss](#/ss \\\"ss命令\\\") 0x2b 43\\nds 0x2b 43\\nes 0x2b 43\\nfs 0x0 0\\ngs 0x33 51\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"当然也可以显示任意一个指定的寄存器值：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"(gdb) i r eax\\neax 0xbffff6a4 -1073744220\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"最后一个要介绍的命令是“q”，退出（Quit）GDB调试环境：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"(gdb) q\\nThe program is running. [exit](#/exit \\\"exit命令\\\") anyway? (y or n)\\n\")])])])\n}]}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler?{\"id\":\"data-v-18591377\",\"hasScoped\":false}!./~/vue-loader/lib/selector.js?type=template&index=0!./~/vue-markdown-loader/lib/markdown-compiler.js?raw!./command/gdb.md\n// module id = 1213\n// module chunks = 382","module.exports = require(\"!!vue-loader!../node_modules/vue-markdown-loader/lib/markdown-compiler.js?raw!./gdb.md\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./command/gdb.md\n// module id = 170\n// module chunks = 382","var Component = require(\"!../node_modules/vue-loader/lib/component-normalizer\")(\n  /* script */\n  null,\n  /* template */\n  require(\"!!../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-18591377\\\",\\\"hasScoped\\\":false}!../node_modules/vue-loader/lib/selector?type=template&index=0!../node_modules/vue-markdown-loader/lib/markdown-compiler.js?raw!./gdb.md\"),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader!./~/vue-markdown-loader/lib/markdown-compiler.js?raw!./command/gdb.md\n// module id = 758\n// module chunks = 382"],"sourceRoot":""}