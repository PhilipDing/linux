{"version":3,"sources":["webpack:///static/js/265.da6ceb50631d99c16a32.js","webpack:///./command/make.md?dfce","webpack:///./command/make.md","webpack:///./command/make.md?e97c"],"names":["webpackJsonp","1353","module","exports","render","_vm","this","_h","$createElement","_self","_c","_m","staticRenderFns","_v","pre","attrs","v-pre","href","title","287","__webpack_require__","876","Component"],"mappings":"AAAAA,cAAc,MAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAgBC,OAAA,WAAmB,GAAAC,GAAAC,KAAaC,EAAAF,EAAAG,cAA0BH,GAAAI,MAAAC,EAC1E,OAAAL,GAAAM,GAAA,IACCC,iBAAA,WAA+B,GAAAP,GAAAC,KAAaC,EAAAF,EAAAG,eAA0BE,EAAAL,EAAAI,MAAAC,IAAAH,CACvE,OAAAG,GAAA,WAAAA,EAAA,KAAAA,EAAA,UAAAL,EAAAQ,GAAA,YAAAR,EAAAQ,GAAA,qDAAAR,EAAAQ,GAAA,KAAAH,EAAA,MAAAL,EAAAQ,GAAA,QAAAR,EAAAQ,GAAA,KAAAH,EAAA,OACAI,KAAA,IACGJ,EAAA,QACHK,OACAC,QAAA,MAEGX,EAAAQ,GAAA,sBAAAR,EAAAQ,GAAA,KAAAH,EAAA,MAAAL,EAAAQ,GAAA,QAAAR,EAAAQ,GAAA,KAAAH,EAAA,OACHI,KAAA,IACGJ,EAAA,QACHK,OACAC,QAAA,MAEGX,EAAAQ,GAAA,8NAAAR,EAAAQ,GAAA,KAAAH,EAAA,KAAAL,EAAAQ,GAAA,sCAAAR,EAAAQ,GAAA,KAAAH,EAAA,OACHI,KAAA,IACGJ,EAAA,QACHK,OACAC,QAAA,MAEGX,EAAAQ,GAAA,2KAAAR,EAAAQ,GAAA,KAAAH,EAAA,MAAAL,EAAAQ,GAAA,QAAAR,EAAAQ,GAAA,KAAAH,EAAA,KAAAL,EAAAQ,GAAA,gBAAAR,EAAAQ,GAAA,KAAAH,EAAA,MAAAL,EAAAQ,GAAA,UAAAR,EAAAQ,GAAA,KAAAH,EAAA,KAAAL,EAAAQ,GAAA,kFAAAH,EAAA,KACHK,OACAE,KAAA,YACAC,MAAA,eAEGb,EAAAQ,GAAA,aAAAR,EAAAQ,GAAA,0GAAAR,EAAAQ,GAAA,KAAAH,EAAA,KAAAL,EAAAQ,GAAA,sBAAAH,EAAA,KACHK,OACAE,KAAA,QACAC,MAAA,WAEGb,EAAAQ,GAAA,SAAAR,EAAAQ,GAAA,4EAAAR,EAAAQ,GAAA,KAAAH,EAAA,KAAAL,EAAAQ,GAAA,+FDUGM,IACA,SAAUjB,EAAQC,EAASiB,GE1CjClB,EAAAC,QAAAiB,EAAA,MFgDMC,IACA,SAAUnB,EAAQC,EAASiB,GGjDjC,GAAAE,GAAAF,EAAA,GAEA,KAEAA,EAAA,MAEA,KAEA,KAEA,KAGAlB,GAAAC,QAAAmB,EAAAnB","file":"static/js/265.da6ceb50631d99c16a32.js","sourcesContent":["webpackJsonp([265],{\n\n/***/ 1353:\n/***/ (function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _vm._m(0)\n},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('section', [_c('p', [_c('strong', [_vm._v(\"make命令\")]), _vm._v(\"是GNU的工程化编译工具，用于编译众多相互关联的源代码问价，以实现工程化的管理，提高开发效率。\")]), _vm._v(\" \"), _c('h3', [_vm._v(\"语法\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"make(选项)(参数)\\n\")])]), _vm._v(\" \"), _c('h3', [_vm._v(\"选项\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"-f：指定“makefile”文件；\\n-i：忽略命令执行返回的出错信息；\\n-s：沉默模式，在执行之前不输出相应的命令行信息；\\n-r：禁止使用build-in规则；\\n-n：非执行模式，输出所有执行命令，但并不执行；\\n-t：更新目标文件；\\n-q：make操作将根据目标文件是否已经更新返回\\\"0\\\"或非\\\"0\\\"的状态信息；\\n-p：输出所有宏定义和目标文件描述；\\n-d：Debug模式，输出有关文件和检测时间的详细信息。\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"Linux下常用选项与Unix系统中稍有不同，下面是不同的部分：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"-c dir：在读取 makefile 之前改变到指定的目录dir；\\n-I dir：当包含其他 makefile文件时，利用该选项指定搜索目录；\\n-h：[help](#/help \\\"help命令\\\")文挡，显示所有的make选项；\\n-[w](#/w \\\"w命令\\\")：在处理 makefile 之前和之后，都显示工作目录。\\n\")])]), _vm._v(\" \"), _c('h3', [_vm._v(\"参数\")]), _vm._v(\" \"), _c('p', [_vm._v(\"目标：指定编译目标。\")]), _vm._v(\" \"), _c('h3', [_vm._v(\"知识扩展\")]), _vm._v(\" \"), _c('p', [_vm._v(\"无论是在linux 还是在Unix环境 中，make都是一个非常重要的编译命令。不管是自己进行项目开发还是安装应用软件，我们都经常要用到make或make \"), _c('a', {\n    attrs: {\n      \"href\": \"#/install\",\n      \"title\": \"install命令\"\n    }\n  }, [_vm._v(\"install\")]), _vm._v(\"。利用make工具，我们可以将大型的开发项目分解成为多个更易于管理的模块，对于一个包括几百个源文件的应用程序，使用make和 makefile工具就可以简洁明快地理顺各个源文件之间纷繁复杂的相互关系。\")]), _vm._v(\" \"), _c('p', [_vm._v(\"而且如此多的源文件，如果每次都要键入\"), _c('a', {\n    attrs: {\n      \"href\": \"#/gcc\",\n      \"title\": \"gcc命令\"\n    }\n  }, [_vm._v(\"gcc\")]), _vm._v(\"命令进行编译的话，那对程序员 来说简直就是一场灾难。而make工具则可自动完成编译工作，并且可以只对程序员在上次编译后修改过的部分进行编译。\")]), _vm._v(\" \"), _c('p', [_vm._v(\"因此，有效的利用make和 makefile工具可以大大提高项目开发的效率。同时掌握make和makefile之后，您也不会再面对着Linux下的应用软件手足无措了。\")])])\n}]}\n\n/***/ }),\n\n/***/ 287:\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(876);\n\n/***/ }),\n\n/***/ 876:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Component = __webpack_require__(5)(\n  /* script */\n  null,\n  /* template */\n  __webpack_require__(1353),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/265.da6ceb50631d99c16a32.js","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _vm._m(0)\n},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('section', [_c('p', [_c('strong', [_vm._v(\"make命令\")]), _vm._v(\"是GNU的工程化编译工具，用于编译众多相互关联的源代码问价，以实现工程化的管理，提高开发效率。\")]), _vm._v(\" \"), _c('h3', [_vm._v(\"语法\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"make(选项)(参数)\\n\")])]), _vm._v(\" \"), _c('h3', [_vm._v(\"选项\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"-f：指定“makefile”文件；\\n-i：忽略命令执行返回的出错信息；\\n-s：沉默模式，在执行之前不输出相应的命令行信息；\\n-r：禁止使用build-in规则；\\n-n：非执行模式，输出所有执行命令，但并不执行；\\n-t：更新目标文件；\\n-q：make操作将根据目标文件是否已经更新返回\\\"0\\\"或非\\\"0\\\"的状态信息；\\n-p：输出所有宏定义和目标文件描述；\\n-d：Debug模式，输出有关文件和检测时间的详细信息。\\n\")])]), _vm._v(\" \"), _c('p', [_vm._v(\"Linux下常用选项与Unix系统中稍有不同，下面是不同的部分：\")]), _vm._v(\" \"), _c('pre', {\n    pre: true\n  }, [_c('code', {\n    attrs: {\n      \"v-pre\": \"\"\n    }\n  }, [_vm._v(\"-c dir：在读取 makefile 之前改变到指定的目录dir；\\n-I dir：当包含其他 makefile文件时，利用该选项指定搜索目录；\\n-h：[help](#/help \\\"help命令\\\")文挡，显示所有的make选项；\\n-[w](#/w \\\"w命令\\\")：在处理 makefile 之前和之后，都显示工作目录。\\n\")])]), _vm._v(\" \"), _c('h3', [_vm._v(\"参数\")]), _vm._v(\" \"), _c('p', [_vm._v(\"目标：指定编译目标。\")]), _vm._v(\" \"), _c('h3', [_vm._v(\"知识扩展\")]), _vm._v(\" \"), _c('p', [_vm._v(\"无论是在linux 还是在Unix环境 中，make都是一个非常重要的编译命令。不管是自己进行项目开发还是安装应用软件，我们都经常要用到make或make \"), _c('a', {\n    attrs: {\n      \"href\": \"#/install\",\n      \"title\": \"install命令\"\n    }\n  }, [_vm._v(\"install\")]), _vm._v(\"。利用make工具，我们可以将大型的开发项目分解成为多个更易于管理的模块，对于一个包括几百个源文件的应用程序，使用make和 makefile工具就可以简洁明快地理顺各个源文件之间纷繁复杂的相互关系。\")]), _vm._v(\" \"), _c('p', [_vm._v(\"而且如此多的源文件，如果每次都要键入\"), _c('a', {\n    attrs: {\n      \"href\": \"#/gcc\",\n      \"title\": \"gcc命令\"\n    }\n  }, [_vm._v(\"gcc\")]), _vm._v(\"命令进行编译的话，那对程序员 来说简直就是一场灾难。而make工具则可自动完成编译工作，并且可以只对程序员在上次编译后修改过的部分进行编译。\")]), _vm._v(\" \"), _c('p', [_vm._v(\"因此，有效的利用make和 makefile工具可以大大提高项目开发的效率。同时掌握make和makefile之后，您也不会再面对着Linux下的应用软件手足无措了。\")])])\n}]}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler?{\"id\":\"data-v-430694fc\",\"hasScoped\":false}!./~/vue-loader/lib/selector.js?type=template&index=0!./~/vue-markdown-loader/lib/markdown-compiler.js?raw!./command/make.md\n// module id = 1353\n// module chunks = 265","module.exports = require(\"!!vue-loader!../node_modules/vue-markdown-loader/lib/markdown-compiler.js?raw!./make.md\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./command/make.md\n// module id = 287\n// module chunks = 265","var Component = require(\"!../node_modules/vue-loader/lib/component-normalizer\")(\n  /* script */\n  null,\n  /* template */\n  require(\"!!../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-430694fc\\\",\\\"hasScoped\\\":false}!../node_modules/vue-loader/lib/selector?type=template&index=0!../node_modules/vue-markdown-loader/lib/markdown-compiler.js?raw!./make.md\"),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader!./~/vue-markdown-loader/lib/markdown-compiler.js?raw!./command/make.md\n// module id = 876\n// module chunks = 265"],"sourceRoot":""}